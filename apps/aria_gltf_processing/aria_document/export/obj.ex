# SPDX-License-Identifier: MIT
# Copyright (c) 2025-present K. S. Ernest (iFire) Lee

defmodule AriaDocument.Export.Obj do
  @moduledoc """
  Wavefront OBJ format exporter.

  Supports exporting both GLTFDocument and FBXDocument sources to OBJ format.
  Handles indexed and non-indexed geometry, materials, and multiple meshes.
  """

  alias AriaGltf.{Document, Mesh, Node, Material}
  alias AriaFbx.Scene
  alias AriaFbx.Document, as: FBXDocument

  @doc """
  Exports a document (GLTF or FBX) to OBJ format.

  ## Options

  - `:mtl_file` - If true, generates an MTL material file (default: `true`)
  - `:base_path` - Base directory for output files (default: directory of obj_path)

  ## Examples

      {:ok, obj_path} = AriaDocument.Export.Obj.export(gltf_document, "/path/to/output.obj")
      {:ok, obj_path} = AriaDocument.Export.Obj.export(fbx_document, "/path/to/output.obj")
  """
  @spec export(AriaGltf.Document.t() | FBXDocument.t(), String.t(), keyword()) ::
          {:ok, String.t()} | {:error, term()}
  def export(%AriaGltf.Document{} = document, obj_path, opts \\ []) do
    export_gltf(document, obj_path, opts)
  end

  def export(%FBXDocument{} = document, obj_path, opts \\ []) do
    export_fbx(document, obj_path, opts)
  end

  def export(_, _, _), do: {:error, :unsupported_document_type}

  defp export_gltf(%AriaGltf.Document{} = document, obj_path, opts) do
    mtl_enabled = Keyword.get(opts, :mtl_file, true)
    base_path = Keyword.get(opts, :base_path, Path.dirname(obj_path))

    with :ok <- ensure_directory_exists(obj_path),
         {:ok, obj_content} <- generate_obj_content_gltf(document),
         :ok <- File.write(obj_path, obj_content) do
      if mtl_enabled do
        mtl_path = obj_path |> Path.rootname() |> Kernel.<>(".mtl")
        case generate_mtl_content_gltf(document, base_path) do
          {:ok, mtl_content} ->
            File.write(mtl_path, mtl_content)
            {:ok, obj_path}

          {:error, _} = error ->
            error
        end
      else
        {:ok, obj_path}
      end
    end
  end

  defp export_fbx(%FBXDocument{} = document, obj_path, opts) do
    mtl_enabled = Keyword.get(opts, :mtl_file, true)
    base_path = Keyword.get(opts, :base_path, Path.dirname(obj_path))

    with :ok <- ensure_directory_exists(obj_path),
         {:ok, obj_content} <- generate_obj_content_fbx(document),
         :ok <- File.write(obj_path, obj_content) do
      if mtl_enabled do
        mtl_path = obj_path |> Path.rootname() |> Kernel.<>(".mtl")
        case generate_mtl_content_fbx(document, base_path) do
          {:ok, mtl_content} ->
            File.write(mtl_path, mtl_content)
            {:ok, obj_path}

          {:error, _} = error ->
            error
        end
      else
        {:ok, obj_path}
      end
    end
  end

  defp ensure_directory_exists(file_path) do
    dir = Path.dirname(file_path)
    File.mkdir_p(dir)
  end

  defp generate_obj_content_gltf(%AriaGltf.Document{} = document) do
    obj_lines = [
      "# OBJ file exported from glTF",
      "# Generated by AriaGltf"
    ]

    # Add MTL reference if materials exist
    if document.materials && length(document.materials) > 0 do
      mtl_name = Path.basename(document |> get_default_output_path() |> Path.rootname(), ".obj")
      obj_lines = obj_lines ++ ["mtllib #{mtl_name}.mtl"]
    end

    # Track vertex offsets for multiple meshes
    vertex_offset = 0
    normal_offset = 0
    texcoord_offset = 0

    # Extract meshes from nodes
    {obj_lines, _vertex_offset, _normal_offset, _texcoord_offset} =
      extract_meshes_from_gltf(document, obj_lines, vertex_offset, normal_offset, texcoord_offset)

    {:ok, Enum.join(obj_lines, "\n") <> "\n"}
  end

  defp generate_obj_content_fbx(%FBXDocument{} = document) do
    obj_lines = [
      "# OBJ file exported from FBX",
      "# Generated by AriaFbx"
    ]

    # Add MTL reference if materials exist
    if document.materials && length(document.materials) > 0 do
      mtl_name = Path.basename(get_default_output_path_fbx(document) |> Path.rootname(), ".obj")
      obj_lines = obj_lines ++ ["mtllib #{mtl_name}.mtl"]
    end

    # Extract meshes from FBX document
    {obj_lines, _vertex_offset, _normal_offset, _texcoord_offset} =
      extract_meshes_from_fbx(document, obj_lines, 0, 0, 0)

    {:ok, Enum.join(obj_lines, "\n") <> "\n"}
  end

  defp extract_meshes_from_gltf(document, obj_lines, vertex_offset, normal_offset, texcoord_offset) do
    meshes = document.meshes || []
    nodes = document.nodes || []

    # TODO: 2025-11-03 fire - Implement full mesh extraction from glTF
    # Need to:
    # - Extract vertices, normals, texcoords from accessors
    # - Handle indexed and non-indexed geometry
    # - Support multiple meshes with proper offsets
    # - Generate face indices with proper vertex/normal/texcoord references

    {obj_lines, vertex_offset, normal_offset, texcoord_offset}
  end

  defp extract_meshes_from_fbx(document, obj_lines, vertex_offset, normal_offset, texcoord_offset) do
    meshes = document.meshes || []

    Enum.reduce(meshes, {obj_lines, vertex_offset, normal_offset, texcoord_offset}, fn mesh,
                                                                                      {lines, v_off,
                                                                                       n_off, t_off} ->
      # Add object name
      mesh_name = mesh.name || "mesh_#{mesh.id}"
      lines = lines ++ ["", "o #{mesh_name}"]

      # Extract vertices
      if mesh.positions do
        {new_lines, new_v_off} = write_vertices(mesh.positions, lines, v_off)
        lines = new_lines
        v_off = new_v_off
      end

      # Extract normals
      if mesh.normals do
        {new_lines, new_n_off} = write_normals(mesh.normals, lines, n_off)
        lines = new_lines
        n_off = new_n_off
      end

      # Extract texture coordinates
      if mesh.texcoords do
        {new_lines, new_t_off} = write_texcoords(mesh.texcoords, lines, t_off)
        lines = new_lines
        t_off = new_t_off
      end

      # Extract faces
      if mesh.indices && mesh.positions do
        lines = write_faces(mesh.indices, lines, v_off, n_off, t_off, mesh.material_ids)
      end

      {lines, v_off, n_off, t_off}
    end)
  end

  defp write_vertices(positions, lines, offset) do
    # Positions are flat list [x1, y1, z1, x2, y2, z2, ...]
    vertex_lines =
      positions
      |> Enum.chunk_every(3)
      |> Enum.map(fn [x, y, z] -> "v #{x} #{y} #{z}" end)

    {lines ++ vertex_lines, offset + length(vertex_lines)}
  end

  defp write_normals(normals, lines, offset) do
    # Normals are flat list [nx1, ny1, nz1, nx2, ny2, nz2, ...]
    normal_lines =
      normals
      |> Enum.chunk_every(3)
      |> Enum.map(fn [nx, ny, nz] -> "vn #{nx} #{ny} #{nz}" end)

    {lines ++ normal_lines, offset + length(normal_lines)}
  end

  defp write_texcoords(texcoords, lines, offset) do
    # Texcoords are flat list [u1, v1, u2, v2, ...] or nested [[u1, v1], [u2, v2], ...]
    texcoord_lines =
      texcoords
      |> Enum.chunk_every(2)
      |> Enum.map(fn [u, v] -> "vt #{u} #{v}" end)

    {lines ++ texcoord_lines, offset + length(texcoord_lines)}
  end

  defp write_faces(indices, lines, vertex_offset, normal_offset, texcoord_offset, material_ids) do
    # TODO: 2025-11-03 fire - Implement face generation from indices
    # Need to:
    # - Triangulate if necessary (OBJ supports triangles and quads)
    # - Handle vertex/normal/texcoord indices correctly
    # - Apply material groups (usemtl)
    # - Handle cases where normals or texcoords may be missing

    # For now, return lines unchanged
    lines
  end

  defp generate_mtl_content_gltf(%AriaGltf.Document{} = document, _base_path) do
    materials = document.materials || []

    mtl_lines = [
      "# MTL file exported from glTF",
      "# Generated by AriaGltf"
    ]

    mtl_lines =
      Enum.reduce(materials, mtl_lines, fn material, acc ->
        name = material.name || "material_#{material.typed_id}"
        acc ++ ["", "newmtl #{name}"]
        # TODO: 2025-11-03 fire - Extract material properties from PBR
      end)

    {:ok, Enum.join(mtl_lines, "\n") <> "\n"}
  end

  defp generate_mtl_content_fbx(%FBXDocument{} = document, _base_path) do
    materials = document.materials || []

    mtl_lines = [
      "# MTL file exported from FBX",
      "# Generated by AriaFbx"
    ]

    mtl_lines =
      Enum.reduce(materials, mtl_lines, fn material, acc ->
        name = material.name || "material_#{material.id}"
        acc ++ ["", "newmtl #{name}"]

        # Add diffuse color
        if material.diffuse_color do
          {r, g, b} = material.diffuse_color
          acc = acc ++ ["Kd #{r} #{g} #{b}"]
        end

        # Add specular color
        if material.specular_color do
          {r, g, b} = material.specular_color
          acc = acc ++ ["Ks #{r} #{g} #{b}"]
        end

        # Add emissive color
        if material.emissive_color do
          {r, g, b} = material.emissive_color
          acc = acc ++ ["Ke #{r} #{g} #{b}"]
        end

        acc
      end)

    {:ok, Enum.join(mtl_lines, "\n") <> "\n"}
  end

  defp get_default_output_path(%AriaGltf.Document{} = _document) do
    "output.obj"
  end

  defp get_default_output_path_fbx(%FBXDocument{} = _document) do
    "output.obj"
  end
end

